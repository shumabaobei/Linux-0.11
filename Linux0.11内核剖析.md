# 1. 内核引导启动以及初始化

## 1.1 从开机加电到执行main函数之前的过程

![](/home/zhhhua/桌面/Linux剖析0.12/图片/9.jpg)

### 1.1.1 启动BIOS，准备实模式下的中断向量表和中断服务程序

```
	本系统所用计算机是基于IA-32系列CPU，安装了标准单色显示器、标准键盘、一个软驱、一块硬盘、16MB内存，在内存中开辟了2MB内存作为虚拟盘，并在BIOS中设置软驱为启动设备。
```

#### 1.1.1.1 BIOS启动原理

```
	Intel将所有80x86系列CPU的硬件设计为加电即进入16位实模式状态运行，同时将CPU硬件逻辑设计为加电瞬间强行将CS值置为0xF000、IP的值置为0xFFF0，这样CS:IP就指向0xFFFF0这个地址位置。而BIOS的入口地址就是0xFFFF0，也就是说，BIOS程序的第一条指令就设计在这个位置。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/53.jpg)

#### 1.1.1.2 BIOS在内存中加载中断向量表和中断服务程序

```
	我们选用的BIOS程序只有8KB，所占地址段为0xFE000-0xFFFFF。现在CS:IP已经指向0xFFFF0这个位置，意味着BIOS开始启动了。随着BIOS程序的执行，屏幕上会显示显卡的信息、内存的信息......说明BIOS程序在检测显卡、内存......这期间，有一项对启动(boot)操作系统至关重要的工作，那就是BIOS在内存中建立中断向量表和中断服务程序。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/54.jpg)

```
	BIOS程序在内存最开始的位置(0x00000)用1KB的内存空间(0x00000-0x003FF)构建中断向量表，在紧挨着它的位置用256字节的内存空间构建BIOS数据区(0x00400-0x004FF)，并在大约57KB以后的位置(0x0E05B)加载了8KB左右的与中断向量表相应的若干中断服务程序。
```

### 1.1.2 加载操作系统内核程序并为保护模式做准备

#### 1.1.2.1 加载第一部分内核代码------引导程序(bootsect)

```
	经过一系列BIOS代码之后，计算机完成了自检等操作。由于我们把软盘设置为启动设备，CPU会接收一个int 0x19中断，把软盘0盘面0磁道1扇区(512B)加载到内存的0x7c00处，将控制权交给引导程序。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/55.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/56.jpg)

#### 1.1.2.2 加载第二部分内核代码------setup

##### 1.1.2.2.1 bootsect对内存的规划

```
	BIOS已经把bootsect也就是引导程序载入内存了，现在它的作用就是把第二批和第三批程序陆续加载到内存中。为了完成这个工作，bootsect首先要做的工作就是规划内存。
```

```
;伪指令 .globl或.global用于定义随后的标识符是外部的或全局的
.globl begtext, begdata, begbss, endtext, enddata, endbss	;定义6个全局标识符
.text
begtext:
.data
begdata:
.bss
begbss:
.text

;setup程序的扇区数值
SETUPLEN = 4				! nr of setup-sectors
;bootsect的段地址
BOOTSEG  = 0x07c0			! original address of boot-sector
;将bootsect移到这里(段地址)
INITSEG  = 0x9000			! we move boot here - out of the way
;setup程序从这里开始(段地址)
SETUPSEG = 0x9020			! setup starts here
;system模块加载到0x10000处(64KB)处
SYSSEG   = 0x1000			! system loaded at 0x10000 (65536).
;停止加载的段地址 ENDSEG=0x1000+0x3000
ENDSEG   = SYSSEG + SYSSIZE		! where to stop loading

! ROOT_DEV:	0x000 - same type of floppy as boot.
!		0x301 - first partition on first drive etc
;设备号0x306指定根文件系统设备是第2个硬盘的第1个分区
ROOT_DEV = 0x306
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/57.jpg)

##### 1.1.2.2.2 复制bootsect

```
(1) 将自身(bootsect 512B内容)从内存0x7c00处复制至内存0x90000处，然后跳转到移动后代码的go标号处。
```

```
(2) 设置ds,es,ss与cs一致，将堆栈指针sp指向0x9ff00(即0x9000:0xff00)。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/58.jpg)

##### 1.1.2.2.3 将setup程序加载到内存

```
	利用BIOS中断int 0x13将setup模块从磁盘第2个扇区开始读到0x90200开始处，共读4个扇区。
```

#### 1.1.2.3 加载第三部分内核代码------system模块

```
	bootsect使用BIOS中断int 0x13将240个扇区的system模块加载进内存。加载工作主要由bootsect调用read_it子程序完成，这个子程序将软盘第6扇区开始的约240个扇区的system模块加载至内存的0x10000处往后的120KB空间中。
	最后执行"jmpi 0,SETUPSEG"这行语句跳转至0x90200处执行。控制权交给setup程序。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/59.jpg)

```
	setup程序做的第一件事情就是利用BIOS提供的中断服务程序从设备上提取内核运行所需的机器系统参数，其中包括光标位置、显示页面等数据，并分别从中断向量0x41和0x45向量值所指的内存地址处获取硬盘参数表1、硬盘参数表2，把它们存放在0x9000:0x0080和0x9000:0x0090处。这些机器系统数据被加载到内存的0x90000-0x901FC位置。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/60.jpg)

### 1.1.3 开始向32位模式转变，为main函数的调用做准备

#### 1.1.3.1 关中断并将system移动到内存地址起始位置0x00000

![](/home/zhhhua/桌面/Linux剖析0.12/图片/61.jpg)

#### 1.1.3.2 设置中断描述符表和全局描述符表

![](/home/zhhhua/桌面/Linux剖析0.12/图片/62.jpg)

#### 1.1.3.3 打开A20，实现32位寻址

![](/home/zhhhua/桌面/Linux剖析0.12/图片/63.jpg)

#### 1.1.3.4 为保护模式下执行head.s做准备

```
(1) 对可编程中断控制器8259A重新编程。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/64.jpg)

```
(2) 将CR0寄存器第0位(PE)置1，设定处理器工作方式为保护模式，执行跳转指令，跳转至head执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/65.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/66.jpg)

#### 当前内存映像

![](/home/zhhhua/桌面/Linux剖析0.12/图片/67.jpg)

#### 1.1.3.5 head.s开始执行

```
	head程序除了做一些调用main的准备工作之外，还做了一件对内核程序在内存中的布局及内核程序的正常运行有重大意义的事，就是用程序自身的代码在程序自身所在的内存空间创建了内存分页机制，即在0x000000的位置创建了页目录表、页表、缓冲区、GDT、IDT，并将head程序已经执行过的代码所占内存空间覆盖。这意味着head程序自己将自己废弃，main函数即将开始执行。
```

 ![](/home/zhhhua/桌面/Linux剖析0.12/图片/68.jpg)

```
(1) 设置各个段寄存器指向内核数据段，设置中断描述符表子程序以及全局描述符表子程序，测试A20地址线是否已经开启。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/69.jpg)

```
	这是重建保护模式下中断服务体系的开始。程序让所有的中断描述符默认指向ignore_int这个位置(将来main函数里面还要让中断描述符对应具体的中断服务程序)，之后对IDTR寄存器的值进行设置。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/70.jpg)

```
	head程序废除已有的GDT，并在内核中的新位置重新创建GDT，并设置GDTR寄存器的值。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/71.jpg)

```
(2) head程序将main函数入口地址压栈。(目的是使head程序执行完后通过ret指令就可以直接执行main函数)
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/72.jpg)

```
(3) 填充页目录表(前4项)和页表(4个)，开启分页机制。
```

```
	先将页目录表和4个页表放在物理内存的起始位置，从内存起始位置开始的5页空间内容清零，为初始化页目录表和页表做准备。(这个动作起到了用1个页目录表和4个页表覆盖head程序自身所占内存空间的作用。)
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/73.jpg)

```
	设置页目录表前4项，使之分别指向4个页表。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/74.jpg)

```
	第4个页表(由pg3指向的位置)的最后一个页表项(pg3+4092指向的位置)指向寻址范围的最后一个页面，即0xFFF000开始的4KB字节大小的内存空间。然后开始从高地址向低地址方向填写4个页表。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/75.jpg)

```
	设置页目录表基址寄存器CR3，使之指向页目录表，再将CR0寄存器最高位(31位)置1.
```

#### system模块在内存中的映像

![](/home/zhhhua/桌面/Linux剖析0.12/图片/77.jpg)

## 1.2 设备环境初始化及激活进程0

### 1.2.1 设置根设备、硬盘

```
	初始化根设备和硬盘，用bootsect写入机器系统数据0x901FC的根设备为软盘的信息，设置软盘为根设备，并用起始自0x90080的32字节的机器系统数据的硬盘参数表设置内核中的硬盘信息drive_info。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/78.jpg)

### 1.2.2 规划物理内存格局，设置缓冲区、虚拟盘、主内存

![](/home/zhhhua/桌面/Linux剖析0.12/图片/1.jpg)

### 1.2.3 设置虚拟盘空间并初始化

```
	首先将虚拟盘的请求项处理函数指针指向do_rd_request()与请求项函数控制结构blk_dev[7]的第二项挂接。之后，将虚拟盘所在的内存区域全部初始化为0。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/116.jpg)

### 1.2.4 内存管理结构men_map初始化

```
	mem_init()函数先将所有的内存页面(1MB以上)使用计数均设置成USED(100，即被使用)，然后再将主内存中的所有页面使用计数全部清零，系统以后只把使用计数为0的页面视为空闲页面。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/79.jpg)

### 1.2.5 异常处理类中断服务程序挂接

```
	trap_init()函数将中断、异常处理的服务程序与IDT进行挂接，逐步重建中断服务体系，支持内核、进程在主机中的运算。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/80.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/81.jpg)

### 1.2.6 初始化块设备请求项结构

```
	进程要想与块设备进行沟通，必须经过主机内存中的缓冲区。请求项管理结构request[32]就是操作系统管理缓冲区中的缓冲块与块设备上逻辑块之间读写关系的数据结构。
```

```
	操作系统根据进程读写任务的轻重缓急，决定缓冲块与块设备之间的读写操作，并把需要操作的缓冲块记录在请求项上，得到读写块设备操作指令后，只根据请求项中的记录来决定当前需要处理哪个设备的哪个逻辑块。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/82.jpg)

```
	request[32]是一个由数组构成的链表，request[i].dev=-1说明这个请求项还没有对应哪个设备，reauest[i].next=NULL说明这事还没有形成请求项队列。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/83.jpg)

### 1.2.7 与建立人机交互界面相关的外设的中断服务程序挂接

#### 1.2.7.1 对串行口进行设置

```
	把两个串行口中断服务程序与IDT相挂接，然后根据tty_table数据结构中的内容对这两个串行口进行初始化设置，包括设置线路控制寄存器的DLAB位、设置发送的波特率因子、设置DTR和RTS......最后允许8259A芯片的IRQ3和IRQ4发送中断请求。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/84.jpg)

#### 1.2.7.2 对显示器进行设置

```
	由于Linux 0.11那个时代，大部分显卡器是单色的，所以我们假设显卡的属性是单色EGA。那么显卡的位置就要被设置为0xb0000-0xb8000，索引寄存器端口被设置为0x3b4，数据寄存器端口被设置为0x3b5，再将显卡的属性------EGA这三个字符显示在屏幕上。初始化一些用于滚屏的变量，其中包括滚屏的起始显存地址、滚屏结束显存地址、最顶端行号以及最低端行号。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/85.jpg)

#### 1.2.7.3 对键盘进行设置

```
	先将键盘中断服务程序与IDT相挂接，然后取消8259A中对键盘中断的屏蔽，允许IRQ1发送中断信号，通过先禁止键盘工作、再允许键盘工作，键盘便能够使用了。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/72.jpg)

### 1.2.8 开机启动时间设置

```
	CMOS是主板上的一个小存储芯片，系统通过调用time_init()函数，先对它上面记录的时间数据进行采集，提取不同等级的时间要素，比如秒、分、年等，然后对这些要素进行整合，并最终得出开机启动时间。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/87.jpg)

### 1.2.9 初始化进程0

```
sched_init()函数中：
	进程0是Linux操作系统中运行的第一个进程，也是Linux操作系统父子进程创建机制的第一个父进程。下面的内容对进程0能够在主机中正常运算的影响最为重要和深远，主要包括如下三方面的内容：
	(1) 系统先初始化进程0。进程0管理结构tast_struct的内容(init_task={INIT_TASK,})已经在代码设计阶段事先设计好了，但这并不代表进程0已经可用了，还要在GDT中设置进程0的TSS和LDT，清空描述符表项、清空任务数组，加载LDT、TSS分别到ldtr、tr寄存器中。
	(2) 设置时钟中断。Linux 0.11作为一个现代操作系统，要支持多进程轮流执行。系统对时钟中断进行设置，以便在进程0运行后，为进程0已经后续由它直接或间接创建出来的进程能够参与多进程调度奠定基础。
	(3) 设置系统调用总入口。进程0要具备处理系统调用的能力。系统通过set_system_gate将system_call与IDT相挂接，这样进程0就具备了处理系统调用的能力了。这个system_call就是系统调用的总入口。
```

#### 1.2.9.1 初始化进程0

```
(1) 初始化GDT中进程0所占的4,5项，即初始化TSS0和LDT0。
set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/12.jpg)

```
(2) 清空task[64]除进程0占用的0项外的其余63项，同时将GDT中的TSS1、LDT1往上的所有表项清零。
(3) 将TR寄存器指向TSS0、LDTR寄存器指向LDT0，这样CPU就能通过TR、LDTR寄存器找到进程0的TSS0、LDT0，也能找到一切和进程0相关的管理信息。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/88.jpg)

#### 1.2.9.2 设置时钟中断

```
(1) 对支持轮询的8253定时器进行设置。(系统每10毫秒发生一次时钟中断)
(2) 将时钟中断处理程序timer_interrupt()与IDT挂接。
(3) 将8259A芯片中与时钟中断相关的屏蔽码打开，时钟中断就可以产生了。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/89.jpg)

#### 1.2.9.3 设置系统调用总入口

```
将系统调用处理函数system_call与int 0x80中断描述符表挂接。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/90.jpg)

### 1.2.10 初始化缓冲区管理结构

```
(1) 操作系统通过hash_table[NR_HASH]、buffer_head双向循环链表组成的复杂的哈希表管理缓冲区。
(2) 从内核的末端及缓冲区的末端同时开始，方向相对增长、配对地做出buffer_head、缓冲块，直到不足一对buffer_head、缓冲块。(在设定的内存格局下，有3000多对buffer_head、缓冲块，buffer_head在低地址端，缓冲块在高地址端)
(3) 对hash_table[307]进行设置，将hash_table[307]的所有项全部设置为NULL。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/91.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/92.jpg)

### 1.2.11 初始化硬盘

```
(1) 将硬盘请求项服务程序do_hd_request()与blk_dev控制结构相挂接。
(2) 将硬盘中断服务程序hd_interrupt()与IDT相挂接，复位主8259A int2的屏蔽位，允许从片发出中断请求信号，复位硬盘的中断请求屏蔽位(在从片上)，允许硬盘控制器发送中断请求信号。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/93.jpg)

### 1.2.12 初始化软盘

```
(1) 将软盘请求项服务程序do_fd_request()与blk_dev控制结构相挂接。
(2) 将软盘中断服务程序floppy_interrupt()与IDT相挂接，复位软盘的中断请求屏蔽位。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/94.jpg)

### 1.2.13 开启中断

```
	现在，系统中所有中断服务程序都已经和IDT正常挂接。这意味着中断服务体系已经构建完毕，系统可以在32位保护模式下处理中断，重要意义之一是可以使用系统调用。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/95.jpg)

### 1.2.14 进程0由0特权级翻转到3特权级，成为真正的进程

```
move_to_user_mode()函数中：
	模仿中断硬件压栈，顺序是ss、esp、eflags、cs、eip，利用iret实现j进程0从0特权级转变为3特权级运行。
```

## 1.3 进程1的创建及执行

### 1.3.1 进程1的创建------fork()系统调用

#### fork()系统调用路线图

![](/home/zhhhua/桌面/Linux剖析0.12/图片/21.jpg)

#### 1.3.1.1 进程0创建进程1

```
(1) 调用fork函数，实际上是执行到unistd.h中的宏函数_syscall0中去，对应代码展开如下：
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/22.jpg)

```
(2) 先执行"0" (__NR_fork)这一行，意思是fork在sys_call_table中对应的函数编号__NR_fork(也就是2)赋值给eax。这个编号即sys_fork()函数在sys_call_table中的偏移值。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/23.jpg)

```
(3) 紧接着执行"int $0x80"，产生一个软中断，CPU从3特权级的进程0代码跳转到0特权级内核代码内核代码中执行。中断使CPU硬件自动将SS、ESP、EFLAGS、CS、EIP这5个寄存器压入进程0内核栈。(注意：压栈的EIP指向当前指令"int $0x80"的下一行，即if(__res>=0)这一行。这一行就是进程0从fork函数系统调用中断返回后第一条指令的位置，同时这一行也将是进程1开始执行的第一条指令位置。)
```

```
(4) CPU自动压栈完成后，跳转到system_call.s中的_system_call处执行，继续将DS、ES、FS、EDX、ECX、EBX压栈(以上一系列的压栈操作都是为了后面调用copy_process函数中初始化进程1中的TSS做准备)。
```

```
(5) 最终，内核通过刚刚设置的eax的偏移量"2"查询sys_call_table[]，得知本次系统调用对应的函数是sys_fork()。因为汇编中对应的C语言的函数名在前面多加一个下划线"_"(如C语言的sys_fork()对应汇编的就是_sys_fork)，所以跳转到_sys_fork处执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/24.jpg)

#### 1.3.1.2 在task[64]中为进程1申请一个空闲位置并获取进程号------find_empty_process()函数

```
		在find_empty_process()函数中，内核用全局变量last_pid来存放系统自开机以来累计的进程数，也将此变量用作新建进程的进程号。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/26.jpg)

```
			接下来(在_sys_fork汇编函数中)，在进程0的内核栈中继续压栈，将5个寄存器值进栈，为调用copy_process()函数准备参数，这些数据也是用来初始化进程1的TSS。
			注意：最后压栈的eax的值就是find_empty_process()函数返回的任务号，也将是copy_process()函数的第一个参数int nr。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/96.jpg)

#### 1.3.1.3 调用copy_process函数

```
总体功能：
(1) 为进程1创建task_struct，将进程0的task_struct的内容复制给进程1。
(2) 为进程1的task_struct、tss做个性化设置。
(3) 为进程1创建第一个页表，将进程0的页表内容赋给这个页表。
(4) 进程1共享进程0的文件。
(5) 设置进程1的GDT项。
(6) 最后将进程1设置为就绪态，使其可以参与进程间的轮转。
```

```
	1> 为进程1创建一个tast_struct结构体，在主内存区中申请一页内存来存放tast_struct结构体，并将当前进程(父进程)的tast_struct内容赋值给子进程。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/28.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/27.jpg)

```
	进入copy_process()函数后，调用get_free_page()函数，在主内存申请一个空闲页面，并将申请到的页面清零，用于进程1的task_struct及内核栈。
	按照get_free_page()函数的算法，是从主内存的末端开始向低地址递进，现在是开机以来，操作系统内核第一次为进程在主内存申请空闲页面，申请到的空闲页面肯定在16MB主内存的最末端。
	*p = *current;只复制task_struct，并未将4KB都复制，即内核0的内核栈并未复制。
```

```
	2> 为进程1的task_struct、tss做个性化设置。
	 2.1> 把当前进程设置为新进程的父进程，清除信号位图并复位新进程各统计值。
	 2.2> 根据当前进程设置任务状态段(TSS)中各寄存器的值。
	  	2.2.1> 由于创建进程时新进程返回值应为0，所以设置tss.eax=0。
		2.2.2> 新建进程内核态堆栈指针tss.esp0设置成新进程任务数据结构所在内存页面的顶端，而堆栈段tss.ss0被设置成内核数据段描述符。
		2.2.3> tss.ldt被设置为局部描述符在GDT中的索引值。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/31.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/29.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/30.jpg)

#### 1.3.1.4 设置进程1的分页管理

```
	3> 为进程1创建第一个页表，将进程0的页表内容赋给这个页表。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/32.jpg)

```
	3.1> 在进程1的线性地址空间中设置代码段、数据段
```

```
	调用copy_mem()函数，先设置进程1的代码段、数据段的段基址、段限长，提取当前进程(进程0)的代码段、数据段以及段限长的信息，并设置进程1的代码段和数据段的基地址。这个基地址就是它的进程号nr*64MB。设置新进程LDT中段描述符中的基地址。
```

```
	3.2> 为进程1创建第一个页表并设置对应的页目录项
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/5.jpg)

```
	调用copy_page_table()函数，为新的页表申请一个空闲页面，并把进程0中的第一个页表里面前160个页表项复制到这个页面中(1个页表项控制一个页面4KB内存空间，160个页表项可以控制640KB内存空间)。最后，用重置CR3的方法刷新页变换高速缓存，进程1的页表和页目录表设置完毕。
```

```
注：进程1此时是一个空架子，还没有对应的程序，它的页表又是从进程0的页表复制过来的，它们管理的页面完全一致，也就是它暂时和进程0共享一套内存页面管理结构，等将来它有了自己的程序，再把关系解除，并重新组织自己的内存管理结构。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/97.jpg)

#### 1.3.1.5 进程1共享进程0的文件

```
4> 进程1共享进程0的文件。
```

```
	设置task_struct中与文件相关的成员，包括打开了哪些文件p->gilp[20]、进程0的"当前工作目录i节点结构"、"当根目录i节点结构"以及"执行文件i节点结构"。
```

#### 1.3.1.6 设置进程1在GDT中的表项

```
	5> 设置进程1的GDT项。把进程1的TSS和LDT挂接到GDT中。
```

![98](/home/zhhhua/桌面/Linux剖析0.12/图片/98.jpg)

#### 1.3.1.7 进程1处于就绪态

```
	将进程1的状态设置为就绪态，使其可以参加进程调度，最后返回进程号1。
```

#### 1.3.1.8 后续操作

```
	system_call函数通过iret中断返回，CPU硬件自动将int 0x80的中断时压的ss、esp、eflags、cs、eip的值按压栈的反序出栈给CPU对应寄存器，从0特权级的内核代码转换到3特权级的进程0代码，CS:EIP指向fork()中int 0x80的下一行if(__res>=0)。对应的代码如下：
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/34.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/35.jpg)

```
	eax里面的值是返回的进程1的进程号1，return (int)__res将"1"返回，回到fork()函数的调用点if(!fork())处执行，!1为假，这样不会执行到init()函数中，而是进程0继续执行，接下来会执行到for(;;)pause()。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/33.jpg)

### 1.3.2 内核第一次做进程调度------schedule()函数

```
在Linux0.11的进程调度机制中，通常有以下两种情况可以产生进程切换：
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/99.jpg)

```
进程0执行for(;;)pause()，最终执行schedule()函数切换到进程1。
```

#### 1.3.2.1 pause()函数

![](/home/zhhhua/桌面/Linux剖析0.12/图片/36.jpg)

```
	pause()函数的调用与fork()函数调用一样，最终执行sys_pause()函数，该函数将进程0设置为可中断等待状态，然后调用schedule()函数进行进程切换。
	
int sys_pause(void)
{
	//将进程0设置为可中断等待状态，如果产生某种中断或其他进程给这个进程发送特定信号
	//才能将该进程的状态改为就绪态
	current->state = TASK_INTERRUPTIBLE;
	schedule();
	return 0;
}
```

#### 1.3.2.2 schedule()函数

```
(1) 首先根据task[64]这个结构，第一次遍历进程，只要地址指针不为空，就要针对它们的"报警定时值alarm"以及"信号位图signal"进行处理。
(2) 第二次遍历所有进程，比较进程的状态和时间片，找出处在就绪态且counter最大的进程。现在只有进程0和进程1，且进程是可中断等待状态，只有进程1处于就绪态，所以执行switch_to(next)，切换到进程1去执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/38.jpg)

#### 1.3.2.3 switch()函数

![](/home/zhhhua/桌面/Linux剖析0.12/图片/7.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/100.jpg)

```
		长跳转至TSS段描述符造成CPU执行任务切换操作。
		ljmp通过CPU的任务门机制并未实际使用任务门，将CPU的各个寄存器保存进进程0的TSS中，将进程1的TSS数据以及LDT代码段、数据段描述符数据恢复给CPU的各个寄存器，实现从0特权级的内核代码切换到3特权级的继承1代码执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/39.jpg)

### 1.3.3 轮转到进程1执行

```
此时进程1的EIP执向的就是fork中的if(__res>=0)这一行，所以，进程1从这一行开始执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/40.jpg)

```
此时的__res的值，就是进程1中的TSS中eax的值，这个值被写死为0，因此fork()返回值为0，main()函数中if(!fork())这一行为"真"，调用init()函数。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/41.jpg)

#### 1.3.3.1 进程1为安装硬盘文件系统做准备

```
总体功能：
(1) 根据机器系统数据设置硬盘参数。
(2) 读取硬盘引导块。
(3) 从引导块中获取信息。
```

```
	1> 进程1设置硬盘的hd_info
```

```
	根据机器系统数据中的drive_info，如硬盘的柱面号、磁头数、扇区数，设置内核的hd_info。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/101.jpg)

```
	2> 读取硬盘的引导块到缓冲区
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/103.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/104.jpg)

```
	2.1> 调用bread()函数实现。
	2.2> 进入bread()函数后，先调用getblk()函数，在缓冲区中申请一个空闲的缓冲块。
	2.3> 在getblk()函数中，先调用get_hash_table()函数查找哈希表，检索此前是否有程序把现在要读的硬盘逻辑块(相同的设备号和块号)已经读取到缓冲取。如果已经读到缓冲区，那就不用再费劲从硬盘读取，直接用现成的。(使用哈希表进行查询的目的是提高查询速度)
	2.4> 进入get_hash_table()函数后，调用find_buffer()函数查找缓冲取中是否有指定设备号、块号的缓冲块。如果能找到指定缓冲块，就直接用。(现在是第一次使用缓冲区，缓冲区中不可能存在已读入的缓冲块，也就是说hash_table中没有挂接任何节点，find_buffer()返回的一定是NULL)
	2.5> 返回getblk()函数，在空闲表中申请一个新的空闲缓冲块。
	2.6> 申请到缓冲块后，对它进行初始化设置，并将这个空闲块挂接到hash_table上。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/102.jpg)

```
	3> 将找到的缓冲块与请求项挂接
```

```
	3.1> 返回bread()函数后，调用ll_rw_block()函数，将缓冲块与请求项挂接。
	3.2> 进入ll_rw_block()函数后，先判断缓冲块对应的设备是否存在或这个设备的请求项函数是否挂接正常。如果存在且正常，则调用make_request()函数，准备将缓冲块与请求项建立关系。
	3.3> 进程1继续执行，进入make_request()函数后，先将这个缓冲块枷锁，目的是保护这个缓冲块在解锁之前不再被任何进程操作。
	3.4> 从请求项结构的最末端开始寻找空闲请求项。之后缓冲块与请求项正式挂接，并对这个请求项各个成员进行初始化。
	3.5> 调用add_request()函数，设置该请求项为当前请求项，并调用硬盘请求项处理函数(dev->request_fn())，即do_hd_request()函数去给硬盘发送读盘命令。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/105.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/106.jpg)

```
	4> 读硬盘
```

```
	4.1> 进入do_hd_request()函数，通过对当前请求项数据成员的分析，解析出需要操作的磁头、扇区、柱面、操作多少扇区等数据。
	4.2> 建立硬盘读盘必要的参数，将磁头移动到0柱面。
	4.3> 根据命令的性质(读/写)给硬盘发送操作命令。
	4.4> 进入hd_out()函数中取执行读盘的最后一步：下达读盘指令。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/107.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/108.jpg)

```
	硬盘开始将引导块中的数据不断读入它的缓存中，同时程序一直返回到bread()函数中。
	现在，硬盘正在继续读引导块。如果程序继续运行，则需要对引导块中的数据进行操作。但这些数据还没有从硬盘中读完，所以调用wait_on_buffer()函数，挂起等待。
	进入wait_on_buffer()函数后，判断刚才申请到的缓冲块是否被加锁。现在，缓冲块确实加锁了，调用sleep_on()函数。
	进入sleep_on()函数后，将进程1设置为不可中断等待状态，进程1挂起，然后调用schedule()函数，准备进程切换。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/109.jpg)

```
	5> 等待硬盘读数据时，进程调度切换到进程0执行
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/110.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/111.jpg)

```
	从这里可以看出操作系统的设计者为进程0设计的特殊职能：当所有进程都挂起或没有任何进程执行的时候，进程0就会出来维持操作系统的基本运转，等待挂起的进程具备可执行的条件。
```

```
	6> 进程0执行过程中发生硬盘中断
```

```
	循环执行一段时间后，硬盘在某一时刻把一个扇区的数据读出来了，产生硬盘中断。CPU接到中断指令后，终止正在执行的程序，终止的位置肯定在pause()、sys_pause()、schedule()、switch_to(n)循环里面的某行指令处。然后转去执行硬盘中断服务程序。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/112.jpg)

```
	中断会自动压栈ss、esp、eflags、cs、eip，硬盘中断服务程序的代码接着将一些寄存器的数据压栈以保存程序的中断处的现场。之后，执行_do_hd处的读盘中断处理程序。
	read_intr()函数会将已经读到硬盘缓冲中的数据复制到刚才被锁定的那个缓冲块中(注：锁定是阻止进程方面的操作，而不是阻止外设方面的操作)，这时1个扇区256字(512字节)的数据读入前面申请到的缓冲块。
	但是，引导块的数据是1024字节，请求项要求的也是1024字节，现在仅读出了一半，硬盘会继续读盘。中断服务程序返回，进程1从刚才硬盘中断打断的地方继续循环，硬盘继续读盘......
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/113.jpg)

```
	又过了一段时间后，硬盘剩下的那一半数据也读完了，硬盘产生中断，重复之前的步骤将剩余一半数据读入缓冲块内。跳到end_request()函数去执行。
	进入end_request()后，将这个缓冲块的更新标志b_uptodate置1，说明它可用。之后调用unlock_buffer()函数为缓冲区解锁，在unlock_buffer()函数中调用wake_up()函数，将等待这个缓冲区解锁的进程(进程1)唤醒(设置为就绪态)。
	硬盘中断处理结束后，进程0继续运行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/114.jpg)

```
	7> 读盘操作完成后，进程调度切换到进程1执行
```

```
	现在，引导盘的两个扇区已经载入内核的缓冲块，进程1已经处于就绪态。当进程0中的循环执行到schedule函数时就会切换到进程1去执行。
	进程1是从"ljmp %0\n\t"\切换走的，所以现在执行它的下一行。吸纳子啊，返回切换到发起者sleep_on()函数中，并最终返回bread()函数中。在bread()函数中判断缓冲块的b_uptodate标志已被设置为1，直接返回，bread()函数执行完毕。
	回到sys_setup函数继续执行，利用从引导块中采集到的分区表信息类来设置hd[]。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/115.jpg)

```
	读引导块的缓冲块已经完成使命，调用brelse()函数释放。
```

#### 1.3.3.2 进程1格式化虚拟盘并更换根设备为虚拟盘

```
	进程1调用rd_load()函数，用软盘上256以后扇区中的信息"格式化"虚拟盘，使之成为一个块设备。
```

```
	进入rd_load()函数后，调用breada()函数从软盘预读一些数据块，也就是"格式化"虚拟盘需要的引导块、超级块。(注：现在根设备是软盘)
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/117.jpg)

```
	分析超级块信息，包括判断文件系统是不是minix文件系统、接下来要载入的根文件系统的数据快数会不会比整个虚拟盘区都大，这些条件都通过，才能继续加载根文件系统。分析完毕，释放缓冲块。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/118.jpg)

```
	接下来调用breada()函数，把文件系统相关的内容，从软盘上拷贝到虚拟盘中，然后及时释放缓冲块，最终完成"格式化"这个过程。
	复制结束后，将虚拟盘设置为根设备。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/119.jpg)

#### 1.3.3.3 进程1在根设备上加载根文件系统

```
加载根文件系统三个主要步骤：
(1) 复制根设备的超级块到super_block[8]中，将根设备中的根i节点挂在super_block[8]中对应根设备的超级块上。
(2) 将驻留缓冲区中16个缓冲块的根设备逻辑块位图、i节点位图分别挂接在super_block[8]中根设备超级块的s_zmap[8]、s_imap[8]上。
(3) 将当前进程的pwd、root指针指向根设备的根i节点。
```

```
加载根文件系统和安装硬盘文件系统完成后的总体效果如下：
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/120.jpg)

```
	1> 复制根设备的超级块到super_block[8]中
```

```
	进入mount_root()函数后，初始化内存中的超级块super_block[8]，将每一项所对应的设备号、加锁标志以及等待它解锁的进程全部设置为0。(注：系统只要想和任何一个设备以文件的形式进行数据交互，就要将这个设备的超级块存储在super_block[8]中，这样可以通过super_block[8]获取这个设备中文件系统的最基本信息，根设备中的超级块也不例外。)
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/121.jpg)

```
	接下来调用read_super()函数，从虚拟盘中读取根设备的超级块，复制到super_block[8]中。
	因为之前没有加载过根文件系统，所以要在super_block[8]中申请一项(此时找到的是super_block[8]d=结构中的第一项)。然后进行初始化并加锁。
	调用bread()函数，把超级块从虚拟盘上读进缓冲区，并从缓冲区复制到super_block[8]的第一项。从现在开始，虚拟盘这个根设备就由super_block[8]的第一项来管理，之后调用brelse()函数释放这个缓冲块。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/123.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/122.jpg)

```
	初始化super_block[8]中的虚拟盘超级块中的i节点位图s_imap、逻辑块位图s_zmap，并把虚拟盘上i节点位图、逻辑块位图所占用的所有逻辑块读到缓冲区，将这些缓冲块分别挂接到s_imap[8]和s_zmap[8]上。由于对它们的操作会比较频繁，所以这些占用的缓冲块并不被释放，它们将常驻在缓冲区内。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/124.jpg)

```
	2> 将根设备中的根i节点挂在super_block[8]中根设备超级块上
```

```
	回到mount_root()函数中，调用iget()函数，从虚拟盘上读取根i节点。根i节点的意义在于，通过它可以到文件系统中任何指定的i节点，也就是能找到任何指定的文件。
	进入iget()函数后，操作系统从i节点表inode_table[32]中申请一个空闲的i节点位置(inode_table[32]是操作系统用来控制同时打开不同文件的最大数)。此时应该是首个节点，对这个i节点进行初始化设置，设置该i节点对应的设备号、节点号。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/125.jpg)

```
	在read_inode()函数中，先给inode_table[32]中的这个i节点加锁。之后，通过该i节点所在的超级块，间接地计算出i节点所在的逻辑块号，并将i节点所在的逻辑块整体读出，从中提取这个i节点的信息，载入刚才加锁的i节点位置上。最后，释放缓冲块并将锁定的i节点解锁。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/126.jpg)

```
下面是加载根文件系统的标志性动作：
	将inode_table[32]中代表虚拟盘根i节点的项挂接到super_block[8]中代表根设备虚拟盘的项中的s_isup、s_imount指针上。这样，操作系统在根设备上可以通过这里建立的关系，一步步地把文件找到。
```

```
	3> 将根文件系统与进程1关联
```

```
	对进程1的task_struct中与文件系统i节点有关的字段进行设置，将根i节点与当前进程(现在就是进程1)关联起来。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/127.jpg)

```
	根据超级块中"逻辑块位图"里记载的信息，计算出虚拟盘上数据块的占用与空闲情况，并将此信息记录到驻留在缓冲区中"装载逻辑块位图信息的缓冲块中"。
```

```
	到此为止，sys_setup()函数就全部执行完毕了。因为这个函数也是由于产生软中断才被调用的，所以返回system_call中执行，之后会执行ret_from_sys_call。这时候的当前进程是进程1，所以下面将调用do_signal()函数(只要当前进程不是进程0，就要执行到这里)，对当前进程的信号位图进行检测。
	现在，当前进程(进程1)并没有接受到信号，调用do_signal()函数并灭有实际的意义。
```

## 1.4 进程2的创建及执行

### 1.4.1 打开终端设备文件及复制文件句柄

```
	shell进程是用户界面进程。计算机用户使用显示器、键盘(终端设备)通过shell进程与操作系统之间进行人机交互。
```

#### 1.4.1.1 打开标准输入设备文件

```
	tty0文件加载后效果图如下：
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/128.jpg)

```
	1> file_table[0]挂接在进程1的filp[0]
```

```
(1) 在加载完根文件系统之后，进程1在其支持下，通过调用open()函数来打开标准输入设备文件。
(2) open()函数执行后产生软中断，并最终映射到内核中sys_open()函数取执行。
(3) 进入sys_open()函数，内核先将进程1的filp[20]与file_table[64]挂接，建立进程与file_table[64]的关系。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/129.jpg)

```
	2> 确定绝对路径起点
```

```
(1) 内核将调用open_namei()函数，最终获取标准输入设备文件的i节点。
(2) 这一目标是通过不断分析路径名来实现的。分析工作的第一阶段是调用dir_namei()函数，获取枝梢i节点，即/dev/tty0路径中dev目录文件的i节点；第二阶段是调用find_entry()函数，通过此i节点，找到dev目录文件中tty0这一目录项，再通过该目录项找到tty0文件的i节点。
(3) dir_namei()函数中将首先调用get_dir()函数来获取枝梢i节点，之后再通过解析路径名，获取tty0目录项的地址和文件名长度信息。
(4) get_dir()函数首先确定路径的绝对起点，即分析"/dev/tty0"这个路径名的第一个字符是不是'/'。如果是'/'，就确定这是绝对路径名，因此将从根i节点开始查找文件。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/130.jpg)

```
	3> 获得dev目录文件i节点
```

```
(1) 从根i节点开始，遍历并解析"/dev/tty0"这个路径名，首先会解析到dev这个目录项，之后将在虚拟盘上找到这个目录项所在的逻辑块，并读进指定的缓冲块。
(2) get_fs_byte()函数会从/dev/tty0路径名dev的'd'字符开始遍历，遇到'/'后跳出循环，namelen数值累加为3。这些信息将和根i节点指针一起，作为find_entry()函数参数使用。find_entry()函数会将目录所在的逻辑块读入缓冲区。
(3) 得到i节点号，就可以得到"dev"目录项所对应目录文件的i节点，内核就可以进而通过i节点找到dev目文件。
(4) inode_table[32]用来管理所有被打开文件的i节点，iget()函数根据i节点号和设备号，将文件i节点载入inode_table[32]。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/131.jpg)

```
	4> 确定dev目录文件i节点为枝梢(topmost)i节点
```

```
获取枝梢i节点、目标文件i节点的执行路线如下：
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/132.jpg)

```
	继续遍历并解析"/dev/tty0"这个路径名。通过dev目录文件，就可以最终找到tty0文件。我们将dev目录文件的i节点，命名为枝梢i节点。
	获取枝梢i节点后，还需要确定目标文件目录名的"首字符地址"和"命名长度"这两个信息，用它们与虚拟盘中存储的目录名进行比对。
```

```
	5> 确定tty0文件的i节点
```

```
	第二阶段获取目标文件i节点的代码与前面获取枝梢i节点的代码的计数路线大体一致，也是通过调用find_entry()函数，将目标文件的目录项(tty0)载入缓冲块，并从目录项中获得i节点号，再调用iget()函数，通过i节点号和设备号，在虚拟盘上获取tty0文件的i节点，最终将此i节点返回。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/133.jpg)

```
	6> 确定tty0是字符设备文件
```

```
	分析tty0文件的i节点属性i_mode，会得知它是设备文件，再通过i节点中的i_zone[0]，确定设备号，并对current->tty好tty_table进行设置。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/134.jpg)

```
	7> 设置file_table[0]
```

```
	sys_open()最后要针对file_table[64]中与进程1的filp[20]对应的表项file_table[0]进行设置。这样，系统通过file_table[64]，建立了进程1与tty0文件(标准输入设备文件)i节点的对应关系。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/135.jpg)

#### 1.4.1.2 打开标准输出、标准错误输出设备文件

```
(1) 使用复制文件句柄的方法打开标准输出、标准错误输出设备文件。
(2) open()函数返回后，进程1在tty0文件已经被打开的基础上，通过调用dup()函数，复制文件句柄，一共复制两次。
(3) dup()函数最终会映射到sys_dup()这个系统调用函数中，并调用到dupfd()函数中，复制文件句柄。
(4) 确定具备复制条件后，在进程1的filp[20]中寻找到空闲项，此时会找到第二项，即filp[1]。将filp[0]中存储的tty0文件指针复制进filp[1]中，并将file_table[0]中f_count文件引用计数这一字段的数值累加为2，以此获得进程1打开标准输出设备文件tty0的效果。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/136.jpg)

```
	dup返回后，进程1再次调用dup()函数，第二次复制文件句柄，构建标准错误输出错误。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/137.jpg)

```
	至此，shell所需要的终端标准输入设备文件、标准输出设备文件和标准错误输出设备文件都已经打开，这也意味着此后可以在程序中使用printf()函数。(stdio.h中的stdio就是standard input/output的意思)
```

###  1.4.2 进程1创建进程2并切换到进程2执行

```
接下来进程1调用fork()函数创建进程2。
```

```
	1> 调用find_empty_process()函数，为进程2寻找空闲task,并确定新的进程号
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/42.jpg)

```
	2> 调用copy_process()函数，为进程2的task_struct以及内核栈申请页面，并复制task_struct，随后对进程2的task_struct进行各种个性化设置，包括各个寄存器的设置、内存页面的管理设置、共享文件的设置、GDT表项的设置等。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/44.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/45.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/46.jpg)

```
	3> 调用wait()函数，最终会映射到系统调用函数sys_waitpid()中执行。此函数功能是：如果进程1有等待退出的子进程，就为该进程的退出做善后工作；如果有子进程，但并不等待退出，则进程进程切换(属于此种情况,切换到进程2)；如果没子进程，函数返回。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/138.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/139.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/140.jpg)

### 1.4.3 加载shell程序

#### 1.4.3.1 关闭标准输入设备文件，打开rc文件

```
1> 轮转到进程2后，调用close()函数关闭标准输入设备文件，并用rc文件替换它。
```

```
	close()函数最终会映射到sys_close()函数中执行。由于进程2继承了进程1的管理信息，因此其filp[20]中文件指针存储情况与进程1是一致的。close(0)就是要将filp[20]第一项清空(就是关闭标准输入设备文件tty0)，并递减file_table[64]中f_count的引用计数。后面调用open()函数，就会在filp[20]中选择第一项来建立进程2与rc文件i节点的关系，以此达到"rc"替换"tty0"的效果。(rc文件是脚本文件，其特点是文件中记录着一些命令，应用程序通过解析这些命令来确定执行任务)
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/141.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/142.jpg)

```
	2> 进程2调用execve()函数开始加载shell程序。
```

```
	execve()函数最终会映射到sys_execve()中执行，最终调用do_execve()函数。
```

#### 1.4.3.2 检测shell文件

```
	1> 检测i节点属性
```

```
	do_execve()开始执行后，先调用namei()函数获取shell文件的i节点。之后检测i节点属性，以此确定shell程序是否具备加载条件。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/143.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/144.jpg)

```
	2> 检测文件头属性
```

```
	通过i节点中提供的设备号和块号(文件头的块号为i_zone[0])信息，将文件头载入缓冲块并获取其信息。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/145.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/146.jpg)

```
	对文件头的信息进行检测，以此进一步确定shell文件的内容是否符合载入的规定。经检测shell文件的文件头属性得知，shell文件的程序具备执行条件。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/147.jpg)

#### 1.4.3.3 为shell程序的执行做准备

```
	1> 加载参数和环境变量
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/159.jpg)

```
	设置参数和环境变量的管理指针表page，并统计参数和环境变量个数，最终将它们复制并映射到进程2的栈空间中。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/148.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/149.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/150.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/151.jpg)

```
	2> 调整进程2的管理结构
```

```
	进程2有了自己对应的程序shell，因此要对自身task_struct进程调整以适应此变化。比如，原来与其父进程(进程1)共享的文件、内存页面，现在要解除关系，要根据shell程序自身情况，量身定做LDT，并设置代码段、数据段、栈段等控制变量。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/152.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/153.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/154.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/155.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/156.jpg)

```
	3> 为执行shell调整EIP和ESP
```

```
	对sys_execve软中断压栈的值进行设置，用shell程序的起始地址值设置EIP，用进程2的新栈顶地址值设置ESP。这样，软中断iret返回后，进程2将从shell程序开始执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/158.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/157.jpg)

#### 1.4.3.4 执行shell程序

```
	1> 执行shell引导加载第一页程序
```

```
	shell程序开始执行后，其线性地址空间对应的程序内容并未加载，也就不存在相应的页面，因此就会产生一个"页异常"中断。此中断会进一步调用"缺页中断"处理程序来分配该页面，并加载 一页shell程序。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/160.jpg)

```
	do_no_page()函数开始执行后，先确定缺页的原因。假如是由于需要加载程序才缺页，会尝试与其他进程共享shell(显然此前没有进程加载过shell，无法共享)，于是申请一个新的页面，并调用bread_page()函数，从虚拟盘上读取4块(4KB、一页)shell程序内容，载入内存页面。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/161.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/162.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/163.jpg)

```
	2> 映射加载页的物理地址和线性地址
```

```
	载入一页的shell程序后，内核会将该页内容映射到shell进程的线性地址空间内，建立页目录表->页表->页面的三级映射管理关系。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/164.jpg)

### 1.4.4 系统实现怠速

#### 1.4.4.1 创建update进程

```
	shell程序开始执行后，要读取标准输入设备文件上的信息，即task_struct中filp[20]第一项所对应文件的信息。进程2即shell程序刚开始时执行就用rc文件替换了标准输入设备文件tty0，因此，shell程序执行后读取的是rc文件上的信息。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/165.jpg)

```
	shell从"/etc/rc"脚本文件中读取了一些命令，其中主要包括以下两条命令：
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/166.jpg)

```
	根据/etc/update这条命令，shell先创建一个新进。这个新进程的进程号是3(shell进程的进程号是2，依次累加，所以它的进程号就是3)。它在task[64]中的"项号"也是3。我们在后面称之为"update进程"。创建完毕后，加载update进程，并最终将执行权转交给update进程，由它去执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/167.jpg)

```
	update进程有一项很重要的任务：将缓冲区中的数据同步到外设(软盘、硬盘等)上。由于主机与外设的数据交换速度远低于主机内部的数据处理速度，因此，当内核需要往外设上写数据的时候，为了提高系统的整体执行效率，并不把数据直接写入外设上，而是先写入缓冲区，之后，根据实际情况，再将数据从缓冲区同步到外设。
	每隔一段时间，update进程就会被唤醒，把数据往外设上同步一次，之后这个进程会被挂起，即被设置为可中断等待状态，等待这下一次被唤醒后继续执行，如此周而复始。
	update进程执行后，并没有同步任务，于是该进程被挂起，系统进行进程调度，最终切换到shell进程继续执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/168.jpg)

#### 1.4.4.2 切换到shell进程执行

```
	上节中介绍到，shell进程处理了rc文件中的第一条命令，创建了update进程。现在处理第二条命令，即echo "/dev/hd1/" > /etc/mtab，将"/dev/hd1/"这一字符串写入虚拟盘中/etc/mtab文件，执行完毕后，shell程序会继续循环调用read()函数读取rc文件上的内容。read()函数对应的系统调用函数是sys_read。
	由于"/etc/rc"文件是普通文件，读取结束后，返回值应该是-ERROR。这个返回值将导致shell进程退出。退出将执行exit()函数，对应的系统调用函数为sys_exit。
	进入do_exit()函数后，开始为shell的退出做善后工作。释放shell进程代码段和数据段所占的内存页面，解除shell进程与其他进程、文件、终端等的关系，将当前进程设置为僵死状态，给进程1发信号通知它shell进程即将退出等。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/169.jpg)

```
	tell_father()函数执行后，会给进程1发送SIGCHLD信号，通知进程1有子进程将要退出。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/170.jpg)

```
	tell_father()函数执行完毕后，调用schedule()函数准备进程切换。此次schedule()函数中对信号的检测，影响到了进程切换。
	调度程序中发现进程1接受到了信号并且处于可中断等待状态，就将进程1设置为就绪态。发现此时只有进程1是就绪态，因此决定切换到进程1去执行。
```

```
	进程1是执行sys_waitpid()函数时调用了schedule()函数，切换到进程2的，所以切换到哦进程1后，会继续执行schedule()函数并最终回到sys_waitpid()函数执行。
	值得注意的是，此时进程1接收到的SIGCHLD信号，就是前面tell_father发送的信号。sys_waitpid()函数的主题程序继续执行。此次执行的区别在于，确实有子进程退出，需要处理。释放shell进程task_struct所在的页面。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/171.jpg)

```
	sys_waitpid()函数执行完毕后，会回到wait()函数，最终返回init()函数中，进程1继续执行。
	值得注意的是，创建完进程2后，pid值为2，而sys_waitpid返回 值flag也为2，即wait()函数返回值为2，while中条件为假，跳出循环。
```

#### 1.4.4.3 重建shell

```
	进程1创建进程4，即重建shell进程。新的shell进程会关闭所有打开的文件，创建新的会话，再重新打开标准输入设备文件、重新打开标准输出设备文件以及重新打开标准错误输出设备文件，最后加载shell进程。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/172.jpg)

```
	值得注意的区别是，shell进程的的进程号由last_pid累加产生，因此为4，但它占用的task[64]的项，是前面已退出的shell进程的项，因此项号仍然是2。另外，此次shell重新打开标准输入设备文件(tty0文件)，而非rc文件，这使得shell开始执行后，不再退出。
	在进入rw_char()函数后，shell进程将被设置为可中断等待状态，这样所有的进程全部都处于可中断等待状态，再次切换到进程0去执行，系统实现怠速。
```

```
	怠速以后，操作系统用户将通过shell进程提供的平台与计算机进行交互。shell进程处理用户指令的工作原理如下：用户通过键盘输入信息，存储在指定的字符缓冲队列上。该缓冲队列上的内容，就是tty0文件的内容。shell程序会不断读取缓冲队列上的数据信息。如果用户没有下达指令，缓冲队列中就不会有数据，shell进程将会被设置为可中断等待状态，即被挂起。如果用户通过键盘下达指令，将产生键盘中断，中断服务程序会将字符信息存储在缓冲队列上，并给shell进程发送信号，信号将导致shell进程被设置为就绪状态，即被唤醒，唤醒后的shell继续从缓冲队列读取数据信息并处理，完毕后，shell进程将再次被挂起，等待下一次键盘中断被唤醒。
```

# 2. 进程管理

![](/home/zhhhua/桌面/Linux剖析0.12/图片/3.jpg)

## 2.1 任务数据结构

```
//任务(进程)数据结构，或称为进程描述符
struct task_struct {
/* these are hardcoded - don't touch */
	long state;						//任务的运行状态(-1不可运行，0可运行(就绪)，>0已停止)
	long counter;					//任务运行时间计数(递减滴答数)，运行时间片
	long priority;						//运行优先级。任务开始运行时counter=priority，越大运行越长
	long signal;						//信号。是位图，每个比特位代表一种信号，信号值位偏移量+1
	struct sigaction sigaction[32];		//信号执行属性结构，对应信号将要执行的操作和标志信息
	long blocked;						//进程信号屏蔽码(对应信号位图)
/* various fields */
	int exit_code;					//任务执行停止的退出码
	unsigned long start_code;	//代码段地址
	unsigned long end_code;		//代码长度(字节数)
	unsigned long end_data;		//代码长度+数据长度(字节数)
	unsigned long brk;			//总长度(字节数)
	unsigned long start_stack; 	//堆栈段地址
	long pid,father;				//进程标识符(进程号)，父进程号
	long pgrp,session,leader;	//进程组号，会话号，回话首领
	unsigned short uid,euid,suid;	//用户标识号(用户id)，有效用户id，保存的用户id
	unsigned short gid,egid,sgid;	//组标识号(组id)，有效组id，保存的组id
	long alarm;					//报警定时值(滴答数)
	long utime;					//用户态运行时间(滴答数)
	long stime;					//系统态运行时间(滴答数)
	long cutime;					//子进程用户态运行时间
	long cstime;					//子进程系统态运行时间
	long start_time;				//进程开始运行时刻
	unsigned short used_math;	//标志：是否使用了协处理器
/* file system info */
	int tty;							//进程使用tty的子设备号。-1表示没有使用
	unsigned short umask;			//文件创建属性性屏蔽位
	struct m_inode * pwd;			//当前工作目录i节点结构
	struct m_inode * root;				//根目录i节点结构
	struct m_inode * executable;		//执行文件i节点结构
	unsigned long close_on_exec;		//执行时关闭文件句柄位图标志
	struct file * filp[NR_OPEN];			//进程使用的文件表结构
/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
	struct desc_struct ldt[3];			//本任务的局部表描述符。0-空，1-代码段cs，2-数据和堆栈段ss&ss
/* tss for this task */
	struct tss_struct tss;				//本进程的任务状态段信息结构
};
```

## 2.2 进程运行状态

![](/home/zhhhua/桌面/Linux剖析0.12/图片/6.jpg)

```
(1) 运行状态(TASK_RUNNING)：进程正在被CPU运行或已经准备就绪随时可由调度程序执行。
(2) 可中断睡眠状态(TASK_INTERRUPTIBLE)：当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以唤醒进程转换到就绪状态。
(3) 不可中断睡眠状态(TASK_UNINTERRUPTIBLE)：除了不会因为收到信号而被唤醒，该状态与可中断睡眠状态类似。但处于该状态的进程只能被wakeup()函数唤醒进入就绪状态。
(4) 暂停状态(TASK_STOPPED)：当进程收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时会进入暂停状态。可向其发送SIGCONT信号让进程转换到可运行状态。在Linux 0.11中还未实现对该状态的转换处理。
(5) 僵死状态(TASK_ZOMBIE)：当进程已停止运行，但其父进程还没有调用wait()询问其状态时，则称该进程处于僵死状态。
```

## 2.3 进程的初始化

```
	在boot/目录中，引导程序把内核从磁盘上加载到内存中，并让系统进入保护模式下运行后，就开始执行系统初始化程序init/main.c。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/173.jpg)

## 2.4 进程创建------fork()系统调用

### fork()系统调用路线图

![](/home/zhhhua/桌面/Linux剖析0.12/图片/21.jpg)

```
(1) 调用find_empty_process()函数------ 在task[64]中为进程申请一个空闲位置并获取进程号
(2) 调用copy_process函数
	1> 为子进程创建一个tast_struct结构体，在主内存区中申请一页内存来存放tast_struct结构体，并将当前进程(父进程)的tast_struct内容赋值给子进程。
	2> 为子进程的task_struct、tss做个性化设置。
		2.1> 把当前进程设置为新进程的父进程，清除信号位图并复位新进程各统计值，并设置初始运行时间片值为15个系统滴答数(150ms)。
		2.2> 根据当前进程设置任务状态段(TSS)中各寄存器的值。
	  		2.2.1> 由于创建进程时新进程返回值应为0，所以设置tss.eax=0。
			2.2.2> 新建进程内核态堆栈指针tss.esp0设置成新进程任务数据结构所在内存页面的顶端，而堆栈段tss.ss0被设置成内核数据段描述符。
			2.2.3> tss.ldt被设置为局部描述符在GDT中的索引值。
	3> 设置新进程的代码和数据段基址、限长，并复制当前进程内存分页管理的页表。
	4> 子进程共享父进程的文件。
		4.1> 设置task_struct中与文件相关的成员，包括打开了哪些文件p->file[20]、父进程的"当前工作目录i节点结构"、"当根目录i节点结构"以及"执行文件i节点结构"。
	5> 设置子进程的GDT项。把子进程的TSS和LDT挂接到GDT中。
	6> 将子进程的状态设置为就绪态，使其可以参加进程调度。
```

## 2.5 进程调度------schedule()函数

![](/home/zhhhua/桌面/Linux剖析0.12/图片/99.jpg)

```
Linux0.11中采用基于优先级排队的调度策略。
```

#### 3.1.4.1 调度程序

```
schedule()函数：
(1) 首先扫描任务数组，比较每个就绪态任务的运行时间递减滴答计数counter的值，哪个进程的counter值大，就表示运行时间还不长，于是就选中该进程，并使用任务切换宏函数切换的该进程进行运行。
(2) 如果所有处于就绪态任务的时间片都已经用完(即counter=0)，系统就会根据每个进程的优先权值priority，对系统中所有进程(包括正在睡眠的进程)重新计算每个任务需要运行的时间片值counter。然后重复(1)的过程。
	计算公式为：counter=counter/2+priority(正在睡眠的进程被唤醒时具有较高的时间片值)
(3) 如果此时没有其他进程可运行，系统就会选择进程0运行。
```

#### 3.1.4.2 进程切换

![](/home/zhhhua/桌面/Linux剖析0.12/图片/7.jpg)

```
长跳转至TSS段描述符造成CPU执行任务切换操作。
```

```
switch_to()函数：
(1) 首先检查要切换的进程是否就是当前进程，如果是则什么也不做，直接退出。
(2) 否则，把内核全局变量current置为新任务的指针，然后长跳转到新任务的任务状态段TSS组成的地址处，造成CPU执行任务切换操作。
(3) 此时，CPU会把其所有寄存器的状态保存到当前任务寄存器TR中TSS段描述符所指向的当前进程任务数据结构的tss结构中，然后把新任务状态段选择符所指向的新任务数据结构中的tss结构中的寄存器信息恢复到CPU中。
```

## 2.6 进程终止------exit()系统调用

```
当一个用户进程调用exit()系统调用时，就会执行内核函数do_exit()。
(1) 该函数会首先释放进程代码段和数据段占用的内存页面，关闭进程打开着的所有文件，对进程使用的当前工作目录、根目录和运行程序的i节点进行同步操作。
(2) 如果进程有子进程，则让init进程(1号进程)作为其所有子进程的父进程。
(3) 如果进程是一个会话头进程并且控制终端，则释放控制终端，并向属于该会话的所有进程发送挂断信号SIGHUP，这通常会终止该会话中的所有进程。
(4) 然后把进程状态设置为TASK_ZOMBIE。
(5) 并向其父进程发送SIGCHLD信号，通知其某个子进程已经终止。
(6) 最后do_exit()调用调度函数取执行其他进程。
```

```
	由此可见，在进程被终止时，它的任务数据结构仍然保留着。在子进程执行期间，父进程通常使用wait()或waitpid()函数等待其某个子进程终止。当等待的子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己进程中。最终释放已终止子进程任务数据结构所占用的内存页面，并置空子进程在任务数组中占用的指针项。
```

# 3. 内存管理

## 3.1 物理内存

### 物理内存各部分的功能示意图

![](/home/zhhhua/桌面/Linux剖析0.12/图片/1.jpg)

## 3.2 内存地址空间概念

```
程序的逻辑地址、CPU的线性地址、实际物理内存地址：
```

### 3.2.1 逻辑地址到物理地址的变换过程

![](/home/zhhhua/桌面/Linux剖析0.12/图片/8.jpg)

### 3.2.2 虚拟地址、线性地址和物理地址之间的关系

#### 3.2.2.1 内核代码和数据地址

![](/home/zhhhua/桌面/Linux剖析0.12/图片/14.jpg)

#### 3.2.2.2 任务0的地址对应关系

![](/home/zhhhua/桌面/Linux剖析0.12/图片/13.jpg)

#### 3.2.2.3 任务1的地址对应关系

![](/home/zhhhua/桌面/Linux剖析0.12/图片/15.jpg)

#### 3.2.2.4 其他任务的地址对应关系

![](/home/zhhhua/桌面/Linux剖析0.12/图片/16.jpg)

## 3.3 分段机制

```
主要功能：
	将逻辑地址转换为32位线性地址。(线性地址=段基地址+逻辑地址)
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/3.jpg)

### 3.3.1 段选择器和描述符高速缓存器的加载过程

![](/home/zhhhua/桌面/C++面试相关/图片/一个操作系统的实现/9.jpg)

```
(1) GDT的线性基地址在GDTR中，又因为每个描述符占8个字节，因此，描述符在表内的偏移地址是索引号乘以8。
(2) 如上图所示，当处理器在执行任何改变段选择器的指令(比如pop、mov、jmp far、call far、iret、retf)，就将指令中提供的索引号乘以8作为偏移地址，同GDTR中提供的线性基地址相加，以访问GDT。如果没有发现什么问题(比如超出了GDT的界限)，就自动将找到的描述符加载到不可见的描述符高速缓存部分。
```

### 3.3.2 保护模式下的内存访问

![](/home/zhhhua/桌面/C++面试相关/图片/一个操作系统的实现/10.jpg)

```
(1) 每当有访问内存的指令时，就不再访问GDT中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。
(2) 如上图所示，因为指令中没有段超越前缀，所以默认使用数据段寄存器DS。执行这条指令时，处理器用DS描述符高速缓存中的线性基地址加上指令中给出的偏移量0x00，形成32位物理地址0x00b8000，并将字符"P"的ASCII码写入该处。
```

### 3.3.3 保护模式下的处理器取指令

![](/home/zhhhua/桌面/C++面试相关/图片/一个操作系统的实现/11.jpg)

```
(1) 不单单是访问数据段，即使是处理器取指令执行时，也采用了相同的方法。
(2) 如上图所示，在32位保护模式下，处理器使用的指令指针寄存器是EIP。假设已经从描述符表中选择了一个段描述符，CS描述符高速缓存器已经装载了正确的32位线性基地址，那么，当处理器取指令时，会自动用描述符高速缓存器中的32位线性基地址加上指令指针寄存器EIP中的32位偏移量，形成32位物理地址，从内存中取得指令并加以执行。同时，EIP的内容自动增加以指向下一条指令。当前指令执行完毕之后，处理器接着按上述方式取下一条指令加以执行。
```

## 7.3 分页机制

```
主要功能：
	将32位线性地址转换为物理地址。(将控制寄存器CR0的最高位(位31)置位开启分页机制)
```

### 页目录表和页表结构示意图

![](/home/zhhhua/桌面/Linux剖析0.12/图片/4.jpg)

### 线性地址变换示意图

![](/home/zhhhua/桌面/Linux剖析0.12/图片/5.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/174.jpg)

### 进程代码和数据在其逻辑地址空间的分布

![](/home/zhhhua/桌面/Linux剖析0.12/图片/175.jpg)

# 4. 文件系统

## 4.1 MINIX文件系统

### 4.1.1 总体布局

![](/home/zhhhua/桌面/Linux剖析0.12/图片/176.jpg)

### 4.1.2 360KB软盘中文件系统实例分析

```
	利用Linux 0.11系统在360KB规格软盘映像中建立一个MINIX 1.0文件系统，其中仅存放了一个名为hello.c的文件。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/180.jpg)

```
	从命令执行后显示的内容可知，该文件系统共含有120个i节点、360个盘块，盘中数据区起始的盘块号是8，逻辑块的大小是1024，与盘块大小相同。并且可存放文件的最大长度为268966912(长度值显然有误)。
```

#### 4.1.2.1 文件系统内容

![](/home/zhhhua/桌面/Linux剖析0.12/图片/181.jpg)

#### 4.1.2.2 引导块

```
	盘块0(0x0000-0x03ff，1KB)是引导块内容。无论你的盘是否用来引导系统，每个新创建的文件系统都会保留一个引导盘块。对于新创建的磁盘映像文件，引导盘块应该全部为零。上述显示数据中引导盘块的内容是原来镜像文件中遗留下来的数据，即mkfs命令在创建文件系统 时不会修改引导盘块的内容。
```

#### 4.1.2.3 超级块

![](/home/zhhhua/桌面/Linux剖析0.12/图片/177.jpg)

```
	盘块1(0x0400-0x07ff，1KB)是超级块内容。根据MINIX文件系统超级块数据结构可知，共有18个字节中包含有效内容。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/182.jpg)

#### 4.1.2.4 i节点位图

```
	盘块2(0x0800-0x0bff，1KB)包含i节点位图信息。由于该文件系统中总共有120个i节点，每个位代表1个i节点结构，因此文件系统实际占用了该1KB大小盘块中的120/8=15个字节，其中位值为0表示文件系统中相应i节点结构未被占用，1表示已占用或保留。盘块中其余不用的字节的位值均被mkfs命令初始化为1。
```

```
	从盘片2的数据中可以看到，第1个字节值是0x07(00000111b)，即i节点位图的最开始的3个位已被占用。第1个位(位0)保留不用。第2和第3个位分别说明了文件系统的1号i节点和2号i节点已被使用，即后面i节点区中已经包含2个i节点结构内容，实际上，1号节点被用作文件系统的根i节点，2号i节点被用于该文件系统上的唯一一个文件hello.c。
```

#### 4.1.2.5 逻辑块位图

```
	盘块3(0x0c00-0x0fff，1KB)是逻辑块位图内容。由于磁盘容量只有360KB，因此文件系统实际使用了其中360个位，即360/8=45个字节。由于逻辑块位图仅表示磁盘中数据区中盘块被占用的情况，因此去除已被使用的功能块数(1引导块+1超级块+1i节点位图块+1逻辑块位图块+4i节点区盘块=8)，实际需要的位数是360-8=352个位(占用44字节)，再加上保留不能使用的位0.共需要353个位。这也是为什么最后一个(第45)字节(0xfe)只有1个位是0的原因。
```

```
	与i节点位图类似，第1个字节的前3位也已经被占用。第1个(位0)位保留不用，第2和第3个位说明磁盘数据区中已经被使用了2个盘块(逻辑块)。实际上，位1代表的磁盘数据区中的第1个盘块被用于1号根i节点存放数据信息(目录项)，位2代表的数据区中第2个盘块被用于2号节点保存相关数据信息。
```

#### 4.1.2.6 i节点

![](/home/zhhhua/桌面/Linux剖析0.12/图片/178.jpg)

```
	盘块4-7(0x1000-0x1fff，4KB)4个盘块专门用来存放i节点结构信息。因为文件系统共有120个i节点，而每个i节点占用32个字节，因此共需要120*32=3840字节，即需要占用4个盘块。由上面显示的数据可以看出，前32个字节已经保存了1号根i节点的内容，随后的32字节中保存了2号i节点的内容。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/183.jpg)

```
	可以看出，1号根i节点的数据块只有1块，其逻辑块号是8，位于磁盘数据区中第1块上，长度是32字节。一个目录项长度是16(0x10)字节，因此这个逻辑块中共存有3个目录项(0x30字节)。因为是一个目录，所以其链接数是2。
	2号i节点的数据块也同样只有1块，并位于磁盘数据区中第2块内，盘块号是9.其中存有的数据长度是74字节，即是hello.c文件的字节长度。
```

#### 4.1.2.7 数据区

```
	盘块8(0x2000-0x23ff，1KB)就是1号根i节点的数据。其中存有48字节的3个目录项结构。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/184.jpg)

```
	盘块9(0x2400-0x27ff，1KB)是hello.c文件内容。其中包含了74字节的文本信息。
```

## 4.2 实例1：用户进程打开一个在硬盘上已存在的文件，并读取文件的内容

![](/home/zhhhua/桌面/Linux剖析0.12/图片/190.jpg)

### 4.2.1 打开文件------open()系统调用

```
打开文件的本质就是要建立*filp[20]、file_table[64]、inode_table[32]三者之间的关系。
这个过程主要分为三个步骤进行：
(1) 将用户进程task_struct中的*filp[20]与内核中的file_table[64]进行挂接。
(2) 以用户给定的路径名"/mnt/user/user1/user2/hello.txt"为线索，找到hello.txt文件的i节点。
(3) 将hello.txt对应的i节点在file_table[64]中进行登记。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/179.jpg)

#### 4.2.1.1 将进程的*filp[20]与file_table[64]挂接

#### 4.2.1.2 获取文件i节点

![](/home/zhhhua/桌面/Linux剖析0.12/图片/185.jpg)

```
	最后调用iget()函数将hello.txt文件i节点载入inode_table[32]中。
```

#### 4.2.1.3 将文件i节点与file_table[64]挂接

### 4.2.2 读文件------read()系统调用

#### 4.2.2.1 确定数据块在外设中的位置

```
在file_read()中，通过调用bmap()函数来确定指定的文件数据块在外设上的逻辑块号。
```

```
i节点通过它的i_zone结构来管理文件数据块：
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/186.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/187.jpg)

#### 4.2.2.2 将数据块读入缓冲块

![](/home/zhhhua/桌面/Linux剖析0.12/图片/188.jpg)

#### 4.2.2.3 将缓冲块中的数据复制到进程空间

![](/home/zhhhua/桌面/Linux剖析0.12/图片/189.jpg)

```
	此时只是从hello.txt文件的起始位置读出了一个数据块(1KB)的数据。通过while不断地循环，将指定数量的数据全部载入用户进程的*buf区域。
```

## 4.3 实例2：用户进程在硬盘上新建一个文件，并将内容写入这个文件

![](/home/zhhhua/桌面/Linux剖析0.12/图片/191.jpg)

### 4.3.1 新建文件------creat()系统调用

#### 4.3.1.1 查找文件

```
	creat()函数最终映射到sys_creat()函数中，直接调用sys_open()函数来创建文件。
	因为是新建文件，此时该文件并不存在。
```

#### 4.3.1.2 新建文件i节点

```
(1) 检查flag中的O_CREAT标志位是否置位。如果确实置位了，就确定用户进程是要新建一个文件。
(2) 调用new_node()函数新建i节点。
	1> 在i节点位图中，对新建i节点对应的位予以标识。
	2> 将i节点的部分属性信息载入inode_table[32]表中指定的表项。
```

#### 4.3.1.3 新建文件目录项

```
	add_entry()函数的任务是：只要在目录文件中寻找到空闲项，就在此位置处加载新目录项；如果确实找不到空闲项，就在外设上创建新的数据块来加载。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/220.jpg)

### 4.3.2 写文件------write()系统调用

```
	操作系统对写文件操作的规定是：进程空间的数据先要写入缓冲区中，然后操作系统在适当的条件下，将缓冲区中的数据同步到外设上。而且，操作系统只能以数据块(1KB)为单位，将缓冲区中的数据块(1KB)的数据同步到外设上。这就需要在同步之前，缓冲块与外设上要写入的逻辑块进行一对一绑定，确定外设上的写入位置，以此保证用户空间写入缓冲块的数据，能够准确地同步到指定逻辑块中。
```

#### 4.3.2.1 确定文件的写入位置

```
(1) 用户进程传递的flags参数决定了文件的数据写入位置。flags=1在文件尾部写入,否则从文件指针f_pos当前指向的位置开始写入数据。
(2) 调用create_block()函数,创建一个新的逻辑块,并使之与i节点中指定的i_zone[9]对应.
	1> 将新建数据块对应的逻辑位图置1.
	2> 在缓冲区中为新建的数据块申请缓冲块,用于承载写入的内容.
```

#### 4.3.2.2 申请缓冲块

```
	调用bread()函数,由于new_block()函数创建的是新缓冲块,所以就无须从外设上载入逻辑块了.
```

#### 4.3.2.3 将指定的数据从进程空间复制到缓冲块

![](/home/zhhhua/桌面/Linux剖析0.12/图片/221.jpg)

```
	此时,用户进程指定的数据只是写入缓冲区中,并未写入硬盘.
```

#### 4.3.2.4 数据同步到外设的两种方法

```
(1) update定期同步;
(2) 因缓冲区使用达到极限,操作系统强行同步.
```

## 4.4 实例3:关闭此文件,之后将其从文件系统中删除 

![](/home/zhhhua/桌面/Linux剖析0.12/图片/223.jpg)

### 4.4.1 关闭文件------close()系统调用                              

#### 4.1.1.1 当前进程的filp与file_table[64]脱钩

```
	close()函数最终映射到sys_close()系统调用函数去执行.将当前进程的task_struct中的filp[20]与file_table[64]解除关系.
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/222.jpg)

#### 4.1.1.2 文件i节点被释放

```
	文件i节点被释放的过程是:先要对i节点的各类属性进行检查,对于实例3,将会检查到i节点的内容已被改变,因此,要先将i节点同步到指定缓冲块中,然后递减i节点的i_count,使i节点的引用计数变为0,这个i节点在inode_table[32]中的表项成为空闲项.
```

### 4.1.2 删除文件------unlink()系统调用

#### 4.1.2.1 对文件的删除条件进行检查

```
	先获取hello.txt文件的i节点,之后检查i节点属性信息、当前进程对该文件的操作权限等信息,确认该文件是否能够删除.
```

#### 4.1.2.2 进行具体的删除工作

![](/home/zhhhua/桌面/Linux剖析0.12/图片/224.jpg)

# 5. 块设备驱动

## 5.1 块设备请求项和请求队列

![](/home/zhhhua/桌面/Linux剖析0.12/图片/196.jpg)

### 5.1.1 块设备项数据结构

![](/home/zhhhua/桌面/Linux剖析0.12/图片/192.jpg)

### 5.1.2 请求项数据结构

![](/home/zhhhua/桌面/Linux剖析0.12/图片/193.jpg)

## 5.2 块设备操作方式(以硬盘为例)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/197.jpg)

### 5.2.1 读操作------bread()函数

#### 5.2.1.1 读取硬盘的引导块到缓冲区

```
(1) 搜索hash表，如果指定设备号、块号的缓冲块已经在高速缓冲区内，则返回对应缓冲区头指针(使用哈希表进行查询的目的是提高查询速度)。
(2) 如果不在，则在空闲表中申请一个新的空闲缓冲块。
(3) 申请到缓冲块后，对它进行初始化设置，并将这个空间块挂接到hash_table上。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/195.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/194.jpg)

#### 5.2.1.2 将找到的缓冲块与请求项挂接

```
(1) 先将缓冲块加锁，然后在请求项结构中申请一个空闲请求项，之后缓冲块与请求项正式挂接，并对请求项各个成员进行初始化。
(2) 把已经设置好的请求项req添加到指定设备的请求项链表中。
		1> 如果该设备的当前请求项指针为空，则可以设置req为当前请求项并立刻调用设备请求项处理函数(do_hd_request())。
		2> 否则就把req请求项插入到该请求项链表中。
```

#### 5.2.1.3 读硬盘

```
(1) 执行硬盘读写请求操作。根据当前请求项中的设备号和起始扇区号信息首先计算得到对应硬盘上的柱面号、当前磁道中扇区号、磁头号数据，然后再根据请求项中的命令(READ对硬盘发送相应读命令。
(2) 下达读盘指令。把读盘服务程序(read_intr())与硬盘中断操作程序相挂接。
```

#### 5.2.1.4 等待硬盘读数据时，进行进程调度

```
	调用wait_on_buffer()函数等待缓冲区解锁。如果缓冲区上锁，则调用sleep_on()函数，将进程设置为不可中断等待状态，然后调用schedule()函数进行进程切换。
```

#### 5.2.1.5 进程0执行过程中发生硬盘中断

```
(1) 进程0循环执行一段时间后，硬盘在某一时刻把一个扇区的数据读出来了，产生硬盘中断。
(2) read_intr()函数会将已经读到硬盘缓存中的数据复制到刚才锁定的那个缓冲块中(注：锁定是阻止进程方面的操作，而不是阻止外设方面的操作)。这时1个扇区256字(512字节)的数据读入前面申请到的缓冲块。
(3) 此时缓冲块的内容已经全部读进来了，将这个缓冲块的更新标志b_uptodate置1，说明可用了。
(4) 最后调用unlock_buffer()函数解锁该缓冲区。调用wake_up()唤醒等待该请求项的进程。释放并从请求项链表中删除本请求项，并把当前请求项指针指向下一请求项。
```





## 5.3 高速缓冲区

### 缓冲头数据结构

![](/home/zhhhua/桌面/Linux剖析0.12/图片/198.jpg)

### 缓冲块组成的双向循环链表(最近最少使用LRU)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/103.jpg)

### 缓冲块散列队列

![](/home/zhhhua/桌面/Linux剖析0.12/图片/104.jpg)

# 6. 字符设备驱动



# 7. 进程间通信

## 7.1 管道机制

```
	操作系统在内存中为每个管道开辟一页内存，给这一页内存赋予了文件的属性。这一页内存由两个进程共享，但不会分配给任何进程，只有内核掌控。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/199.jpg)

### 实例1

![](/home/zhhhua/桌面/Linux剖析0.12/图片/202.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/201.jpg)

### 7.1.1 管道的创建过程

#### 7.1.1.1 为管道文件在file_table[64]中申请空闲项

```
	创建文件都是让当前进程(一个进程)使用，而管道文件就是为了两个进程(读管道进程和写管道进程)的使用而创建的。实例1中管道是由父进程(写管道进程)创建的。父进程在创建管道时，处处为子进程(读管道进程)做准备，使得子进程一旦被创建，天然就具备操作管道的能力。
```

```
	父进程先在file_table[64]中申请"两个"空闲项，并将这两个空闲项的引用计数设置为1，表示它们被引用了，父子进程以后操作管道文件可以各用一项。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/203.jpg)

#### 7.1.1.2 进程task_struct中的*filp[20]与file_table[64]中的表项挂接

![](/home/zhhhua/桌面/Linux剖析0.12/图片/204.jpg)

#### 7.1.1.3 创建管道文件i节点

```
(1) 先为该管道文件在inode_table[32]中申请一个i节点。
(2) 由于管道的本质就是一个内存页面，系统申请一个空闲内存页面，并将该页面的地址载入i节点。值得注意的是，此刻inode->i_size字段承载的不再是文件大小，而是内存页面的起始地址。
(3) 让读管道指针和写管道指针都指向管道(其实就是这个空项页面)的起始地址，并将该i节点的属性设置为"管道型i节点"，即它并不是实际存储硬盘上的文件的i节点，只是一个内存页面。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/205.jpg)

#### 7.1.1.4 将管道文件i节点与file_table[64]建立联系

![](/home/zhhhua/桌面/Linux剖析0.12/图片/206.jpg)

#### 7.1.1.5 将管道文件句柄返给用户进程

```
	现在将管道文件的两个句柄返给用户进程，即返回给实例1代码中的fd[2]。这个数组有两项，每一项分别存放一个句柄，这样子进程也将继承这两个文件句柄，父子两个进程就可以通过不同的文件句柄操作这个管道文件了。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/207.jpg)

### 7.1.2 管道的操作

```
	Linux0.11管道操作要实现的效果是，读管道进程执行时，如果管道中有未读数据，就读取数据。没有未读数据，就挂起，这样就不会读取垃圾数据；写管道进程执行时，如果管道中有剩余空间，就写入数据，没有剩余空间了，就挂起，这样就不会覆盖尚未读取的数据。另外，管道大小只有一个页面，所以写或读到页面尾端后，读写指针要能够回滚到页面首端以便继续操作。
```

```
	下面通过实例1介绍管道操作的过程：
```

#### 7.1.2.1 读管道进程开始操作管道文件

```
	实例1中父进程创建完管道后，开始创建子进程，即读管道进程。假设读管道先执行，执行实例1中"read(fd[0], str2, strlen(str2))"这行源代码。read()函数最终执行到read_pipe()函数中。由于管道内没有任何数据，所以此时系统会将读管道进程挂起，然后切换到写管道进程中取执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/208.jpg)

#### 7.1.2.2 写管道进程向管道中写入数据

```
	写管道进程开始执行，它会将实例1中的str1数组中指定的1024字节的数据循环地写入管道，即执行"write(fd[1], str1, strlen(str1))"这行源代码。write()函数最终执行到write_pipe()函数中。写完后，管道中就已经有数据可以读出，唤醒读管道进程(唤醒了读管道进程并不等于读管道进程就立即执行)，此次写管道操作就执行完毕。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/209.jpg)

#### 7.1.2.3 写管道进程继续向管道写入数据

```
	当前进程是写管道进程，写完一次管道之后将返回用户空间。通过实例1中"for(i=0; i<10000; i++)"这行代码可知，写管道要操作10000次，而写管道进程的时间片还没有用完，还要继续执行写管道操作。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/210.jpg)

#### 7.1.2.4 写管道进程已将管道空间写满

```
	不妨假设在写管道进程工作的过程中，发生了时钟中断，削减了它的时间片，只要时间片不被削减为0，它就会继续执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/211.jpg)

```
	直到写管道进程把管道写满为止(写入4095字节就算满了)。在写入的过程中，写管道指针一直指向数据的写入位置，一直向管道尾端移动。
```

#### 7.1.2.5 写管道进程挂起

```
	写满后，系统就要将写管道进程挂起，然后切换到读管道进程去执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/212.jpg)

#### 7.1.2.6 读管道进程从管道中读出数据

```
	读管道进程将继续在read_pipe()函数中执行。根据实例1的代码，此次执行将会把管道中512字节的数据读入读管道进程的用户空间内。
	读出了数据，意味着有了剩余空间，系统此时会唤醒写管道进程。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/213.jpg)

#### 7.1.2.7 读管道进程继续执行，不断从管道中读出数据

```
	当前进程还是读管道进程，读一次管道之后将返回用户空间。通过实例1中"for(j=0; j<20000; j++)"这行代码可知，读管道要操作20000次，而且读管道进程的时间片还没有用完，所以还要继续执行读管道操作。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/214.jpg)

#### 7.1.2.8 读管道进行执行中发生时钟中断

```
	假设在读管道进程工作的过程中，也发生了时钟中断，削减了它的时间片，只要时间片不被削减为0，它就会继续执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/215.jpg)

#### 7.1.2.9 读管道进程执行过程中再次发生时钟中断

```
	读管道进程执行过程中又一次发生时钟中断后，读管道进程时间片为0，它被挂起并切换到写管道进程去执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/216.jpg)

#### 7.1.2.10 读管道进程切换到写管道进程执行

```
	写管道进程挂起前，管道操作指针已经被移动至管道首端。接下来，写管道进程将从管道首端开始，继续往管道中写入数据，直到再次没有剩余空间为止。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/217.jpg)

#### 7.1.2.11 写管道进程挂起，切换到读管道

```
	管道中再次被写满后，写管道进程又要被系统挂起，之后就切换到读管道进程取执行。Linux0.11重新分配时间片的原则是当所有处于就绪态的进程时间片均为0时，分配时间片。由于此时读管道进程是唯一处于就绪态的进程，并且它的时间片也用完了，重新给它们分配时间片。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/218.jpg)

#### 7.1.2.12 读管道进程继续执行，直到把管道中的数据读完

```
	读管道进程开始执行后，将继续把管道中的数据读出。当操作到管道尾端后，也会将读管道指针从管道尾端移动至管道首端，并从首端继续读取管道中的内容，直至将数据彻底读完，两个指针重合。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/219.jpg)

## 7.2 信号机制

```
	信号机制是Linux 0.11为进程提供的一套"局部的类中断机制"，即在进程执行的过程中，如果系统发现某个进程接收到了信号，就暂时打断进程的执行，转而去执行该进程的信号处理程序，处理完毕后，再从进程被"被打断"之处继续执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/227.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/228.jpg)

### 7.2.1 实例2------信号的发送、接收及处理

```
有两个用户进程。一个进程用来接收及处理信号，名字叫做processsig。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/225.jpg)

```
另一个进程用来发送信号，名字叫做sendsig。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/226.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/229.jpg)

#### 7.2.1.1 processsig进程开始执行

```
	进入main()函数后，先要将用户自定义的信号处理函数与processsig进程绑定，即对peocesssig进程task_struct中的sigaction[32]进行设置。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/230.jpg)

#### 7.2.1.2 processsig进程进入可中断等待状态

```
	为了体现信号对进程执行状态的影响，调用pause()函数将进程设置为"可中断等待状态"。
```

#### 7.2.1.3 sendsig进程开始执行并向processsig进程发信号

```
(1) processsig进程暂时挂起，sendsig进程执行。
(2) 将SIGUSER1信号发送给peocesssig进程，即在该进程信号位图中添加指定的信号(置位)。
(3) sendsig进程继续执行，随着时钟中断不断产生，时间片将被削减为0，导致进程切换。
(4) schedule()函数中遍历到processsig进程后，检测到其接收了信号，将其设置为就绪态。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/231.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/232.jpg)

#### 7.2.1.4 系统检测当前进程接收到信号并准备处理

```
	processsig进程开始执行后，会继续在for循环中执行pause()函数。由于这个函数最终会映射到sys_pause()这个系统调用中取执行，所以当系统调用返回时，就一定会执行到ret_from_sys_call:标号处，并最终调用do_signal()函数，开始着手处理processsig进程的信号。
```

#### 7.2.1.5 调整processsig进程的内核栈结构，使其系统调用返回后，先执行信号处理函数

```
	这里所做的准备工作的核心目的就是对用户栈的数据进行调整，使得此次系统调用返回后会"首先"执行processsig进程的"信号处理函数"，然后从用户进程"中断位置"继续执行。
	软中断产生后，Linux 0.11就在此次系统调用返回前，先把这些"内核栈"中保存的寄存器值备份在当前进程的"用户栈"中，然后对"内核栈"中的这些原有的寄存器值进行更改。这就使得系统调用函数返回后，首先根据"内核栈"中最新更改的数据转到用户空间的信号处理函数处执行。进入用户空间后，"用户栈"就该发挥作用了，等到信号处理完毕后，在通过前面备份在用户空间的"指令和数据"，返回"中断位置"处执行。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/233.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/234.jpg)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/235.jpg)

### 7.2.2 信号对进程执行状态的影响

#### 7.2.2.1 可中断等待案例

![](/home/zhhhua/桌面/Linux剖析0.12/图片/236.jpg)

```
	shell进程创建了这个用户进程(该进程就自然成为shell进程的子进程)后，又被设置为可中断等待状态。
```

```
(1) 用户进程退出并向shell进程发送信号
```

```
	用户程序先调用exit()函数来处理自己退出前的一些事务，包括将自己的程序所占用的内存页面释放、解除该进程与操作系统文件的关系，之后，给shell进程发送"子进程退出"信号，通知shell进程，自己即将退出，最后将自己设置为僵死状态并调用schedule()函数，准备进程切换。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/237.jpg)

```
(2) shell进程被唤醒并调度执行
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/238.jpg)

```
	之后，第二次遍历所有进程，当前只有shell进程是就绪态，于是切换到shell进程去执行。
```

```
(3) shell进程执行，为子进程退出做最后的处理
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/239.jpg)

```
(4) shell进程再次被挂起
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/240.jpg)

```
	由此可见，对处于可中断等待状态的进程而言，给她发信号，schedule()函数执行时会检测到它接收的信号和它的状态，并将其该设为就绪态，以此唤醒该进程。
```

#### 7.2.2.2 不可中断等待案例

![](/home/zhhhua/桌面/Linux剖析0.12/图片/241.jpg)

```
(1) 进程A由于等待读盘而被挂起
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/242.jpg)

```
(2) 进程A切换到进程B执行
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/243.jpg)

```
(3) 进程A虽收到信号，但无法唤醒
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/244.jpg)

```
(4) 由于外设数据读取完成，进程A被唤醒
```

```
	进程C执行了一段时间后，进程A指定的数据已经从硬盘上读出，于是硬盘中断服务程序会将进程A强行设置为就绪态(这也是将处于不可中断等待状态的进程该设为就绪态的唯一方法)。
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/245.jpg)

```
(5) 切换到进程A执行并处理信号
```

![](/home/zhhhua/桌面/Linux剖析0.12/图片/246.jpg)

```
	由此可见，对处于不可中断等待状态的进程而言，除直接将其设置为就绪态之外，没有任何办法将它的状态改为就绪态，是否接收信号都没意义。
```





### 2.1.3 Linux系统中的堆栈

#### 2.1.3.1 刚进入保护模式内核堆栈使用情况

![](/home/zhhhua/桌面/Linux剖析0.12/图片/17.jpg)

#### 2.1.3.2 任务的堆栈

##### 在用户态运行时(除了任务0、任务1)

![](/home/zhhhua/桌面/Linux剖析0.12/图片/18.jpg)

```
	每个任务(除了任务0和任务1)有自己的64MB地址空间。当一个任务(进程)刚被创建时，它的用户态堆栈指针被设置在其地址空间的靠近末端(64MB顶端)部分。实际上末端部分还要包括执行程序的参数和环境变量，然后才是用户堆栈空间。应用程序在用户态下运行就一直使用这个堆栈。
```

##### 在内核态运行时

![](/home/zhhhua/桌面/Linux剖析0.12/图片/19.jpg)

```
	任务内核态堆栈被设置在位于其任务数据结构所在页面的末端，即与任务的任务数据结构(task_struct)放在同一页面内。设置如下：
	p->tss.esp0 = PAGE_SIZE + (long)p;
	p->tss.ss0 = 0x10;
```

##### 任务0和任务1的堆栈

```
(1) 内核态堆栈：任务0和任务1的内核态堆栈分别位于各自任务数据结构所在页面的末端。
(2) 用户态堆栈：任务0的用户态堆栈就是进入保护模式后所使用的堆栈，即sched.c的user_stack[]数组。由于任务1在创建时复制了任务0的用户堆栈，因此刚开始任务0和任务1共享使用同一个用户堆栈空间。但是当任务1开始运行时，由于任务1映射到user_stack[]处的页表项被设置成只读，使得任务1在执行堆栈操作时将会引起写页面异常，从而内核会使用写时复制机制为任务1另行分配主内存区页面作为堆栈空间使用。只有到此时，任务1才开始使用自己独立的用户堆栈页面。
```

#### 2.1.3.3 任务内核态堆栈与用户态堆栈之间的切换

![](/home/zhhhua/桌面/Linux剖析0.12/图片/20.jpg)

,./